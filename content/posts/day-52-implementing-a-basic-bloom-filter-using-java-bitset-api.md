+++
category = []
date = 2022-07-21T00:00:00Z
description = "Implementing a basic bloom filter to understand its concepts and usages using Java BitSet api"
draft = true
showtoc = false
slug = "/java/100DaysOfJava/day64"
summary = "Implementing a basic bloom filter to understand its concepts and usages using Java BitSet api"
title = "Day 64: Implementing a basic Bloom Filter Using Java BitSet api"
[cover]
alt = "Day54"
caption = "Day54"
image = ""
relative = false

+++
First of all lets understand what is a Bloom Filter and how does it work and what are its usages.

Bloom Filter :

Bloom filter is a data structure designed to tell you, rapidly and memory-efficiently, whether an element is present in a set.

The price paid for this efficiency is that a Bloom filter is a **probabilistic data structure**: it tells us that the element either _definitely is not_ in the set or _may be_ in the set

For example, checking availability of username. In this case its a set membership problem, where the set is the list of all registered username. The price we pay for efficiency is that it is probabilistic in nature. That means, there might be some False Positive results. **False positive means**, it might tell that given username is already taken but actually it’s not.

![Bloom Filters: Visuals for explanation and applied systems | by Brian  Femiano | Level Up Coding](https://miro.medium.com/max/1400/1*hCwivv91BuskNzZ1ebq6jw.png)

here in this scenario we are searching for the user name `Mary` in the bloom filter. So from the picture we can see a bloom filter is a combination of a hash function and a bit array or list. Where after hashing the user name will give us a number in which we will set the bit to true.

So if we use different hash functions and then  update the bit array with 1 where the index of the array would be number provided by the hash function. Then if we search the name again with those hash functions and check the index's again and if we find 1 there then we can plausibly say that, that name exist in the bloom filter.

So, in a nutshell:

* If we search for a value and see any of the hashed indexes for this value is ‘0’ then, the value is definitely not on the list.
* If all of the hashed indexes is ‘1’ then ‘maybe’ the searched value is on the list.

Properties :

* unlike a standard hash table, a Bloom filter of a fixed size can represent a set with large number of elements.
* False positive rate increases steadily as elements are added until all bits in the filter are set to 1, at which point all queries yield a positive result.

So let us discuss what is false positive in the case of getting information from a bloom filter.

The question is why we said **“Probabilistic”**, why this uncertainty? Let’s understand this with an example. Suppose we want to check whether “Mohibul” is present or not. We’ll calculate hashes using h1, h2 and h3 functions

```java
String name = "Mohibul";
h1(name) % 10 = 5;
h2(name) % 10 = 2;
h3(name) % 10 = 4;
```

If we check the bit array, bits at these indices are set to 1.

Now lets check for another name "Mary"

```java
String name = "Mary"
h1(name) % 10 = 1;
h2(name) % 10 = 2;
h3(name) % 10 = 5;
```

but we know that “Mary” was never added to the filter. Bit at index 2 and 5 was set when we added “Mohibul” . And if another name made 1 bit true then this bloom filter will say that "Mary" exists in the filter but in real we didnt add Mary.

This behavior causes false positives.

* Bloom filters never generate **false negative** result, i.e., telling you that a username doesn’t exist when it actually exists.
* Deleting elements from filter is not possible. Because, if we delete a single element by clearing bits at indices generated by k hash functions, it might cause deletion of few other elements. Example – if we delete “geeks” (in given example below) by clearing bit at 1, 4 and 7, we might end up deleting “nerd” also Because bit at index 4 becomes 0 and bloom filter claims that “nerd” is not present.

Let us make a bloom filter ourselves.

Before doing that let us ask some question that will help us better design and understand

1. What are these hash functions?
2. How big should I make the bloom filters?
3. How many hash functions should i use?
4. Benefits of bloom filter?
5. Where can I use them?

#### What is Hash functions

The hash functions used in a Bloom filter should be independent and uniformly distributed. They should also be as fast as possible (cryptographic hashes such as `sha1`, though widely used thus are not very good choices).

Examples of fast, simple hashes that are independent enough includes [murmur](https://sites.google.com/site/murmurhash/ "murmur hash"), [xxHash](https://github.com/Cyan4973/xxHash "xxHash"), [Fowler–Noll–Vo hash function](https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function "Fowler-Noll-Vo hash ")  and many others

#### How big should I make the bloom filters

It's a nice property of Bloom filters that you can modify the false positive rate of your filter. A larger filter will have less false positives, and a smaller one more.

Your false positive rate (P) will be approximately

```math
(1-e^((-kn)/m)))^k
```

so you can just plug the number n of elements you expect to insert, and try various values of k and m to configure your filter for your application.  
  
Here   
m - is the size of the bit array
n - is the number of elements
k - is the number hash funtions

 

This leads to an obvious question 

#### How many hash functions should I use? 

The more hash functions you have, the slower your bloom filter, and the quicker it fills up. If you have too few, however, you may suffer too many false positives.

Since you have to pick k when you create the filter, you'll have to ballpark what range you expect n to be in. Once you have that, you still have to choose a potential m (the number of bits) and k (the number of hash functions).


So now we can design a process to build a bloom filter

* Choose a approx value for n
* Choose a value for m
* Calculate the optimal value of k
* Calculate the error rate for our chosen values of n, m, and k. If it's unacceptable, return to step 2 and change m; otherwise we're done.